SQL활용 시험문제

4.
	1)




5. 	1) 사원이름이 S로 끝나는 데이터 출력
	-> SELECT * FROM EMP WHERE ENAME LIKE '%S';
	2) 30번 부서에 있는 사원중 직책이 SALESMAN인 사원의 사원번호,이름,직책,급여,부서번호출력
	-> SELECT EMPNO, ENAME, JOB, SAL, DEPTNO FROM EMP WHERE DEPTNO=30 AND JOB='SALESMAN';
	3) 20, 30번 부서에 있는사운중 급여야 2000초과인 사원을 집합을 쓴방식, 안쓴방식으로 출력
	안쓴방식-> SELECT EMPNO, ENAME, JOB, SAL, DEPTNO FROM EMP WHERE DEPTNO IN(20,30) AND SAL > 2000;
	
	집합 -> SELECT EMPNO, ENAME, JOB, SAL, DEPTNO FROM EMP WHERE DEPTNO IN(20,30)
			INTERSECT
			SELECT EMPNO, ENAME, JOB, SAL, DEPTNO FROM EMP WHERE SAL > 2000;
	
	4) NOT BETWEEN~ 연산자를 쓰지않고 급여가 2000이상 3000이하 이외의 사원 데이터 출력하기
	-> SELECT * FROM EMP WHERE SAL < 2000 OR SAL > 3000;
	5) 부서번호 30 중 이름에 E가 포함되어있는 사원중 급여가 1000~2000 사이가 아닌 사원이름,번호,급여,부서번호 출력
	-> SELECT * FROM EMP WHERE DEPTNO=30 AND ENAME LIKE '%E%' AND SAL NOT BETWEEN 1000 AND 2000;	
	6) 추가수당이 존재하지 않고 상급자가 있고 직책이 MANAGER, CLERK인 사원중에 이름두번째들짜가 L이 아닌 사원정보 출력
	-> SELECT * FROM EMP WHERE MGR IS NOT NULL AND COMM IS NULL AND JOB IN('MANAGER', 'CLERK') AND ENAME NOT LIKE '_L%';



6.
	1) EMPNO, MASKING_EMPNO, ENAME, MASKING_ENAME 출력하기(M_EMPNO는73**, M_ENAME은 S****)
	-> SELECT EMPNO, RPAD(SUBSTR(EMPNO, 1, 2),4, '*') "MASKING_EMPNO",
				ENAME, RPAD(SUBSTR(ENAME, 1, 1),5, '*') "MASKING_ENAME" FROM EMP;
	2) 일급, 시급 구하기
	-> SELECT EMPNO, ENAME, SAL, TRUNC(SAL / 21.5, 2)"일급", ROUND(SAL/ 21.5/ 8, 1) "일급"
		FROM EMP;
	3) 3개월후 정직원, NULL값 변경하기
	-> SELECT EMPNO, ENAME, HIREDATE, TO_CHAR(NEXT_DAY(ADD_MONTHS(HIREDATE, 3), '월'), 'YYYY-MM-DD') "정직원 변환날짜",
		NVL(TO_CHAR(COMM), 'N/A') "COMM" FROM EMP;
	4) 매니저 번호
	-> SELECT EMPNO, ENAME, MGR,
			CASE
			WHEN MGR IS NULL THEN '0000'
			WHEN SUBSTR(MGR, 1, 2) = 75 THEN '5555'
			WHEN SUBSTR(MGR, 1, 2) = 76 THEN '6666'
			WHEN SUBSTR(MGR, 1, 2) = 77 THEN '7777'
			WHEN SUBSTR(MGR, 1, 2) = 78 THEN '8888'
			ELSE TO_CHAR(MGR)
			END "CHG_MGR" FROM EMP;
	





7. 
	1) EMP테이블을 이용해 부서번호, 평균급여, 최고급여, 최저급여, 사원수를 출력하는데 소수점을 제외하고 부서번호별로 출력하기
	-> SELECT DEPTNO, TRUNC(AVG(SAL)), MAX(SAL), MIN(SAL), COUNT(*) FROM EMP GROUP BY DEPTNO;
	2) 같은 직책에 종사하는 사원이 3명이상인 직책과 인원수 출력하기
	-> SELECT JOB, COUNT(*) FROM EMP GROUP BY JOB HAVING COUNT(*) >= 3;
	3) 사원들의 입사연도를 기준으로 부서별로 몇명 입사 했는지 출력하기
	-> SELECT TO_CHAR(HIREDATE, 'YYYY'), DEPTNO, COUNT(*) FROM EMP GROUP BY TO_CHAR(HIREDATE, 'YYYY'), DEPTNO;
	4) 추가 수당을 받는 수와 받지 않는 수를 출력하기
	-> SELECT NVL2(COMM, 'O', 'X'), COUNT(*) FROM EMP GROUP BY NVL2(COMM, 'O', 'X');
	5) 각 부서의 입사 연도별 사원수, 최고 급여, 급여합, 평균급여를 출력하고 각 부서별 소계와 총계를 구하기
	-> SELECT DEPTNO, TO_CHAR(HIREDATE, 'YYYY'), COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL) FROM EMP
		GROUP BY ROLLUP(DEPTNO, TO_CHAR(HIREDATE, 'YYYY'));
		





8. 
	1) 급여 2000 초과인 사원들의 부서정보, 사원정보 입력하기 SQL-99이전, 이후
	이전 -> SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL FROM EMP E, DEPT D
	WHERE E.DEPTNO = D.DEPTNO AND SAL > 2000;
	
	이후 -> SELECT DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL FROM EMP E NATURAL JOIN DEPT D
	WHERE SAL > 2000;

	2) 부서별 평균급여 최대급여 최소급여, 사원수 출력하기
	이전 -> SELECT D.DEPTNO, D.DNAME, TRUNC(AVG(SAL)), MAX(SAL), MIN(SAL), COUNT(*) FROM EMP E, DEPT D
		WHERE E.DEPTNO = D.DEPTNO GROUP BY D.DEPTNO, D.DNAME;
		
	이후 -> SELECT DEPTNO, D.DNAME, TRUNC(AVG(SAL)), MAX(SAL), MIN(SAL), COUNT(*)
			FROM EMP E JOIN DEPT D USING (DEPTNO) GROUP BY DEPTNO, D.DNAME
			
	3) 모든 부서정보와 사원정보를 오른쪽과 같이 부서번호와 사원 이름 순으로 정렬해서 출력하기
	이전 -> SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL FROM EMP E DEPT D
			WHERE E.DEPTNO(+) = D.DEPTNO ORDER BY DEPTNO, ENAME;
	
	이후 -> SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL
			FROM EMP E RIGHT OUTER JOIN DEPT D ON (E.DEPTNO = D.DEPTNO) ORDER BY DEPTNO, ENAME;
	
	4) 모든 부서정보 사원정보 급여등급정보 각 사원의 직속 상관의 정보를 부서번호, 사원번호 순서로 정렬후 출력하기
	이전 -> SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.MGR, E.SAL, E.DEPTNO,
			S.LOSAL, S.HISAL, S.GRADE, E2.EMPNO, E2.ENAME FROM EMP E, DEPT D, SALGRADE S, EMP E2
			WHERE E.DEPTNO(+) = D.DEPTNO
			AND E.SAL BETWEEN S.LOSAL(+) AND S.HISAL(+)
			AND E.MGR = E2.EMPNO(+)
			ORDER BY D.DEPTNO, E.EMPNO;
	
	이후 -> SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.MGR, E.SAL, E.DEPTNO,
			S.LOSAL, S.HISAL, S.GRADE, E2.EMPNO, E2.ENAME
			FROM EMP E RIGHT OUTER JOIN DEPT D ON(E.DEPTNO = D.DEPTNO)
						LEFT OUTER JOIN SALGRADE S ON(E.SAL BETWEEN S.LOSAL AND S.HISAL)
						LEFT OUTER JOIN EMP E2 ON(E.MGR = E2.EMPNO)
						ORDER BY D.DEPTNO, E.EMPNO;



9. 
	1) ALLEN과 같은 직책인 사원들의 사원정보 부서정보를 출력하기
	-> SELECT E.JOB, E.EMPNO, E.ENAME, E.SAL, D.DEPTNO, D.DNAME
	   FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO AND JOB = (SELECT JOB FROM EMP WHERE ENAME='ALLEN')
	2) 모든사원의 평균급여보다 높은 급여를 받는 사원들의 사원정보, 부서정보, 급여등급 정보를 출력하기(급여 내림차순, 부서번호 오름차순)
	-> SELECT E.EMPNO, E.ENAME, D.DNAME, E.HIREDATE, D.LOC, E.SAL, S.GRADE FROM EMP E, DEPT D, SALGRADE S
	   WHERE E.DEPTNO = D.DEPTNO AND E.SAL BETWEEN S.LOSAL AND S.HISAL AND SAL > (SELECT AVG(SAL) FROM EMP)
	   ORDER BY SAL DESC, D.DEPTNO;
	3) 10번부서에 근무하는 사원중 30번 부서에 존재하지 않는 직책을 가진 사원들의 사원정보 부서정보 출력
	-> SELECT E.EMPNO, E.ENAME, E.JOB, D.DEPTNO, D.DNAME, D.LOC FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO
	   AND E.DEPTNO = 10 AND JOB NOT IN (SELECT DISTINCT JOB FROM EMP WHERE DEPTNO=30);
	   
	4) 직책이 SALESMAN인 사람들의 최고 급여보다 높은 급여를 받는 사원들의 사원정보, 급여등급 출력하기(다중행함수 O,X 두개출력)
	X -> SELECT E.EMPNO, E.ENAME, E.SAL, S.GRADE FROM EMP E, SALGRADE S
		WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL AND SAL > (SELECT MAX(SAL) FROM EMP WHERE JOB='SALESMAN') ORDER BY E.EMPNO;
	O -> SELECT E.EMPNO, E.ENAME, E.SAL, S.GRADE FROM EMP E, SALGRADE S
		WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL AND SAL > ALL (SELECT DISTINCT SAL FROM EMP WHERE JOB = 'SALESMAN') ORDER BY E. EMPNO;




10. 
	1) 각 테이블 복사
	-> CREATE TABLE HW_EMP AS SELECT * FROM EMP; ....
	2) 등록한 HW_DEPT 테이블에 50, 60, 70, 80번 부서 등록하기
	-> INSERT INTO HW_DEPT (DEPTNO, DNAME, LOC) VALUES (50, 'ORACLE', 'BUSAN');....
	3) HW_EMP테이블에 새로운 사원등록하기
	-> INSERT INTO HW_EMP VALUES 
	(7201, 'TEST_USER1', 'MANAGER', 7788, TO_DATE(2016-01-02, 'YYYY-MM-DD'), 4500, NULL, 50);...
	4) 50번부서 사원중 평균급여보다 급여가 많은 사원이면 70번 부서로 옮기기
	-> UPDATE HW_EMP SET DEPTNO = 70 
	   WHERE SAL > (SELECT AVG(SAL) FROM HW_EMP WHERE DEPTNO=50);
	5) 60번 부서사원중 입사일이 가장 빠른사원보다 늦게 입사한 사원의 급여를 10퍼 인상, 80번부서로 옮기기
	-> UPDATE HW_EMP SET SAL = SAL * 1.1, DEPTNO = 80 WHERE 
	   HIREDATE > (SELECT MIN(HIREDATE) FROM HW_EMP WHERE DEPTNO = 60);
	   
	6) HW_EMP 사원중 급여등급이 5등급인 사원을 삭제하기
	-> DELETE FROM HW_EMP WHERE EMPNO IN(SELECT E.EMPNO FROM HW_EMP E, HW_SALGRADE S
	   WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL AND S.GRADE = 5);




12.
	1) EMP_HW 테이블 
	-> CREATE TABLE EMP_HW (.....);
	2) 만든 테이블에 새로운 컬럼 BIGO 열 추가하기
	-> ALTER TABLE EMP_HW ADD COLUMN BIGO VARCHAR2(20);
	3) 만든컬럼 BIGO의 열크기를 30으로 변경하기
	-> ALTER TABLE EMP_HW MODIFY BIGO VARCHAR2(30);
	4) 만든컬럼 BIGO의 이름을 REMARK로 변경하기
	-> ALTER TABLE EMP_HW RENAME COLUMN BIGO TO REMARK;
	5) 만든 EMP_HW 테이블에 EMP테이블의 정보 넣기, REMARK부분은 NULL로 넣기
	-> INSERT INTO EMP_HW SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO, NULL 
	   FROM EMP;
	그후 조회 -> SELECT * FROM EMP_HW;
	6) EMP_HW 테이블 삭제하기
	-> DROP TABLE EMP_HW;





13.
	1) EMP테이블과 같은 구조의 데이터를 저장하는 테이블 만들기 
	-> CREATE TABLE EMPIDX AS SELECT * FROM EMP;
	2) 생성한 테이블에 IDX_EMPIDX_EMPNO라는 인덱스를 EMPNO에 만들기
	-> CREATE INDEX IDX_EMPIDX_EMPNO ON EMPIDX (EMPNO);
	3) 생성한 인덱스 데이서 사전뷰를 통해 확인하기
	-> SELECT * FROM USER_INDEXES WHERE INDEX_NAME='IDX_EMPIDX_EMPNO';
	
	4) 방금 생성한 EMPIDX 테이블의 데이터중 급여가 1500초과인 사원들만 출력하는 
	   EMPIDX_OVER15K 뷰 생성하기 사원번호, 이름, 직책, 부서번호, 급여, 추가수당열을 가지고 있다,
	   추가수당열에 수당이 있으면 'O' 없으면 'X'로 출력하기
	-> CREATE OR REPLACE VIEW EMPIDX_OVER15K
	   AS(EMPNO, ENAME, JOB, DEPTNO, SAL, NVL2(COMM,'O','X') "COMM" FROM EMPIDX
	   WHERE SAL > 1500;
	   
	5) DEPT 테이블과 같은정보를 가진 DEPTSEQ 테이블 생성
	-> CREATE TABLE DEPTSEQ AS SELECT * FROM DEPT;
	   생성한 테이블에 DEPTNO열에 사용할 시퀀스를 생성
	-> CREATE SEQUENCE SEQ_DEPT
			INCREMENT BY 1
			START WITH 1
			MAXVALUE 99
			MINVALUE 1
			NOCYCLE NOCACHE;
	6) 생성한 DEPTSEQ테이블에 위 시퀀스를 이용하여 정보 넣기
	-> INSERT INTO DEPTSEQ (DEPTNO, DNAME, LOC) VALUES (SEQ_DEPT.NEXTVAL, 'DATABASE', 'SEOUL');
	-> INSERT INTO DEPTSEQ (DEPTNO, DNAME, LOC) VALUES (SEQ_DEPT.NEXTVAL, 'WEB', 'BUSAN');
	-> INSERT INTO DEPTSEQ (DEPTNO, DNAME, LOC) VALUES (SEQ_DEPT.NEXTVAL, 'MOBILE', 'ILSAN');




14. 제약조건을 가진 테이블 생성
	DEPTNO NUMBER(2) CONSTRAINT "DEPTCONST_DEPTNO_PK" PRIMARY KEY,.....
	SAL NUMBER(7,2) CONSTRAINT "EMPCONST_SAL_CHK" CHECK(BETWEEN 1000 AND 9999),.....
	DEPTNO NUMBER(2) CONSTRAINT "EMPCONST_DEPTNO_FK" REFERENCES DEPT_CONST (DEPTNO)
	
	비교하기
	SELECT TABLE_NAME, CONSTRAINT_NAME, CONSTRAINT_TYPE
	FROM USER_CONSTRAINTS WHERE TABLE_NAME IN('DEPT_CONST', 'EMP_CONST')
	ORDER BY CONSTRAINT_NAME;
	




15. 
	1) 계정 생성 : SYSTEM계정 접속 -> CREATE USER 계정명 IDENTIFIED BY 비밀번호;
	접속 권한부여 : GRANT CREATE SESSION TO 계정명
	EX) cmd -> sqlpuls system/_aA123456 -> CREATE USER PREW_HW IDENTIFIED BY ORCL;
				GRANT CREATE SESSION TO PREW_HW
	
	
	2) 다른계정 테이블 접속 권한부여 : 다른계정 접속 -> GRANT SELECT ON 테이블명 TO 권한을 줄계정
	EX) CONN SCOTT/tiger -> GRANT SELECT ON SALGRADE TO PREW_HW;
	
	
	3) 다른계정 테이블 접속 권한취소 : 다른계정 접속 -> REVOKE SELECT ON 테이블명 FROM 권할을 취소할 계정
	EX) CONN SCOTT/tiger -> REVOKE SELECT ON SALGRADE FROM PREW_HW;